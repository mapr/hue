// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: security.proto

#ifndef PROTOBUF_security_2eproto__INCLUDED
#define PROTOBUF_security_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace mapr {
namespace fs {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_security_2eproto();
void protobuf_AssignDesc_security_2eproto();
void protobuf_ShutdownFile_security_2eproto();

class CredentialsMsg;
class SecurityPrincipal;
class AclEntry;
class AccessControlList;
class Key;
class Ticket;
class TicketAndKey;
class AuthenticationReq;
class AuthenticationReqFull;
class AuthenticationResp;
class TicketDescriptor;

enum SecurityProg {
  ChallengeResponseProc = 1
};
bool SecurityProg_IsValid(int value);
const SecurityProg SecurityProg_MIN = ChallengeResponseProc;
const SecurityProg SecurityProg_MAX = ChallengeResponseProc;
const int SecurityProg_ARRAYSIZE = SecurityProg_MAX + 1;

enum ServerKeyType {
  CldbKey = 0,
  ServerKey = 1,
  MfsUtilKey = 2,
  ClusterKey = 3,
  ServerKeyTypeMax = 4
};
bool ServerKeyType_IsValid(int value);
const ServerKeyType ServerKeyType_MIN = CldbKey;
const ServerKeyType ServerKeyType_MAX = ServerKeyTypeMax;
const int ServerKeyType_ARRAYSIZE = ServerKeyType_MAX + 1;

// ===================================================================

class CredentialsMsg : public ::google::protobuf::MessageLite {
 public:
  CredentialsMsg();
  virtual ~CredentialsMsg();

  CredentialsMsg(const CredentialsMsg& from);

  inline CredentialsMsg& operator=(const CredentialsMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const CredentialsMsg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CredentialsMsg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CredentialsMsg* other);

  // implements Message ----------------------------------------------

  CredentialsMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CredentialsMsg& from);
  void MergeFrom(const CredentialsMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // repeated uint32 gids = 2;
  inline int gids_size() const;
  inline void clear_gids();
  static const int kGidsFieldNumber = 2;
  inline ::google::protobuf::uint32 gids(int index) const;
  inline void set_gids(int index, ::google::protobuf::uint32 value);
  inline void add_gids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      gids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_gids();

  // optional bool isRoot = 3;
  inline bool has_isroot() const;
  inline void clear_isroot();
  static const int kIsRootFieldNumber = 3;
  inline bool isroot() const;
  inline void set_isroot(bool value);

  // optional string userName = 4;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 4;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:mapr.fs.CredentialsMsg)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_isroot();
  inline void clear_has_isroot();
  inline void set_has_username();
  inline void clear_has_username();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > gids_;
  ::google::protobuf::uint32 uid_;
  bool isroot_;
  ::std::string* username_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_security_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_security_2eproto();
  #endif
  friend void protobuf_AssignDesc_security_2eproto();
  friend void protobuf_ShutdownFile_security_2eproto();

  void InitAsDefaultInstance();
  static CredentialsMsg* default_instance_;
};
// -------------------------------------------------------------------

class SecurityPrincipal : public ::google::protobuf::MessageLite {
 public:
  SecurityPrincipal();
  virtual ~SecurityPrincipal();

  SecurityPrincipal(const SecurityPrincipal& from);

  inline SecurityPrincipal& operator=(const SecurityPrincipal& from) {
    CopyFrom(from);
    return *this;
  }

  static const SecurityPrincipal& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SecurityPrincipal* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SecurityPrincipal* other);

  // implements Message ----------------------------------------------

  SecurityPrincipal* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SecurityPrincipal& from);
  void MergeFrom(const SecurityPrincipal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 princId = 1;
  inline bool has_princid() const;
  inline void clear_princid();
  static const int kPrincIdFieldNumber = 1;
  inline ::google::protobuf::uint32 princid() const;
  inline void set_princid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mapr.fs.SecurityPrincipal)
 private:
  inline void set_has_princid();
  inline void clear_has_princid();

  ::google::protobuf::uint32 princid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_security_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_security_2eproto();
  #endif
  friend void protobuf_AssignDesc_security_2eproto();
  friend void protobuf_ShutdownFile_security_2eproto();

  void InitAsDefaultInstance();
  static SecurityPrincipal* default_instance_;
};
// -------------------------------------------------------------------

class AclEntry : public ::google::protobuf::MessageLite {
 public:
  AclEntry();
  virtual ~AclEntry();

  AclEntry(const AclEntry& from);

  inline AclEntry& operator=(const AclEntry& from) {
    CopyFrom(from);
    return *this;
  }

  static const AclEntry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AclEntry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AclEntry* other);

  // implements Message ----------------------------------------------

  AclEntry* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AclEntry& from);
  void MergeFrom(const AclEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mapr.fs.SecurityPrincipal principal = 1;
  inline bool has_principal() const;
  inline void clear_principal();
  static const int kPrincipalFieldNumber = 1;
  inline const ::mapr::fs::SecurityPrincipal& principal() const;
  inline ::mapr::fs::SecurityPrincipal* mutable_principal();
  inline ::mapr::fs::SecurityPrincipal* release_principal();
  inline void set_allocated_principal(::mapr::fs::SecurityPrincipal* principal);

  // optional uint32 allow = 2;
  inline bool has_allow() const;
  inline void clear_allow();
  static const int kAllowFieldNumber = 2;
  inline ::google::protobuf::uint32 allow() const;
  inline void set_allow(::google::protobuf::uint32 value);

  // optional uint32 deny = 3;
  inline bool has_deny() const;
  inline void clear_deny();
  static const int kDenyFieldNumber = 3;
  inline ::google::protobuf::uint32 deny() const;
  inline void set_deny(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mapr.fs.AclEntry)
 private:
  inline void set_has_principal();
  inline void clear_has_principal();
  inline void set_has_allow();
  inline void clear_has_allow();
  inline void set_has_deny();
  inline void clear_has_deny();

  ::mapr::fs::SecurityPrincipal* principal_;
  ::google::protobuf::uint32 allow_;
  ::google::protobuf::uint32 deny_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_security_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_security_2eproto();
  #endif
  friend void protobuf_AssignDesc_security_2eproto();
  friend void protobuf_ShutdownFile_security_2eproto();

  void InitAsDefaultInstance();
  static AclEntry* default_instance_;
};
// -------------------------------------------------------------------

class AccessControlList : public ::google::protobuf::MessageLite {
 public:
  AccessControlList();
  virtual ~AccessControlList();

  AccessControlList(const AccessControlList& from);

  inline AccessControlList& operator=(const AccessControlList& from) {
    CopyFrom(from);
    return *this;
  }

  static const AccessControlList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AccessControlList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AccessControlList* other);

  // implements Message ----------------------------------------------

  AccessControlList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AccessControlList& from);
  void MergeFrom(const AccessControlList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mapr.fs.AclEntry acl = 1;
  inline int acl_size() const;
  inline void clear_acl();
  static const int kAclFieldNumber = 1;
  inline const ::mapr::fs::AclEntry& acl(int index) const;
  inline ::mapr::fs::AclEntry* mutable_acl(int index);
  inline ::mapr::fs::AclEntry* add_acl();
  inline const ::google::protobuf::RepeatedPtrField< ::mapr::fs::AclEntry >&
      acl() const;
  inline ::google::protobuf::RepeatedPtrField< ::mapr::fs::AclEntry >*
      mutable_acl();

  // @@protoc_insertion_point(class_scope:mapr.fs.AccessControlList)
 private:

  ::google::protobuf::RepeatedPtrField< ::mapr::fs::AclEntry > acl_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_security_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_security_2eproto();
  #endif
  friend void protobuf_AssignDesc_security_2eproto();
  friend void protobuf_ShutdownFile_security_2eproto();

  void InitAsDefaultInstance();
  static AccessControlList* default_instance_;
};
// -------------------------------------------------------------------

class Key : public ::google::protobuf::MessageLite {
 public:
  Key();
  virtual ~Key();

  Key(const Key& from);

  inline Key& operator=(const Key& from) {
    CopyFrom(from);
    return *this;
  }

  static const Key& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Key* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Key* other);

  // implements Message ----------------------------------------------

  Key* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Key& from);
  void MergeFrom(const Key& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:mapr.fs.Key)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::std::string* key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_security_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_security_2eproto();
  #endif
  friend void protobuf_AssignDesc_security_2eproto();
  friend void protobuf_ShutdownFile_security_2eproto();

  void InitAsDefaultInstance();
  static Key* default_instance_;
};
// -------------------------------------------------------------------

class Ticket : public ::google::protobuf::MessageLite {
 public:
  Ticket();
  virtual ~Ticket();

  Ticket(const Ticket& from);

  inline Ticket& operator=(const Ticket& from) {
    CopyFrom(from);
    return *this;
  }

  static const Ticket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Ticket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Ticket* other);

  // implements Message ----------------------------------------------

  Ticket* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Ticket& from);
  void MergeFrom(const Ticket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mapr.fs.CredentialsMsg userCreds = 1;
  inline bool has_usercreds() const;
  inline void clear_usercreds();
  static const int kUserCredsFieldNumber = 1;
  inline const ::mapr::fs::CredentialsMsg& usercreds() const;
  inline ::mapr::fs::CredentialsMsg* mutable_usercreds();
  inline ::mapr::fs::CredentialsMsg* release_usercreds();
  inline void set_allocated_usercreds(::mapr::fs::CredentialsMsg* usercreds);

  // optional .mapr.fs.Key userKey = 2;
  inline bool has_userkey() const;
  inline void clear_userkey();
  static const int kUserKeyFieldNumber = 2;
  inline const ::mapr::fs::Key& userkey() const;
  inline ::mapr::fs::Key* mutable_userkey();
  inline ::mapr::fs::Key* release_userkey();
  inline void set_allocated_userkey(::mapr::fs::Key* userkey);

  // optional uint64 expiryTime = 3;
  inline bool has_expirytime() const;
  inline void clear_expirytime();
  static const int kExpiryTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 expirytime() const;
  inline void set_expirytime(::google::protobuf::uint64 value);

  // optional uint64 creationTimeSec = 4;
  inline bool has_creationtimesec() const;
  inline void clear_creationtimesec();
  static const int kCreationTimeSecFieldNumber = 4;
  inline ::google::protobuf::uint64 creationtimesec() const;
  inline void set_creationtimesec(::google::protobuf::uint64 value);

  // optional uint64 maxRenewalDurationSec = 5;
  inline bool has_maxrenewaldurationsec() const;
  inline void clear_maxrenewaldurationsec();
  static const int kMaxRenewalDurationSecFieldNumber = 5;
  inline ::google::protobuf::uint64 maxrenewaldurationsec() const;
  inline void set_maxrenewaldurationsec(::google::protobuf::uint64 value);

  // optional bool isExternal = 6;
  inline bool has_isexternal() const;
  inline void clear_isexternal();
  static const int kIsExternalFieldNumber = 6;
  inline bool isexternal() const;
  inline void set_isexternal(bool value);

  // @@protoc_insertion_point(class_scope:mapr.fs.Ticket)
 private:
  inline void set_has_usercreds();
  inline void clear_has_usercreds();
  inline void set_has_userkey();
  inline void clear_has_userkey();
  inline void set_has_expirytime();
  inline void clear_has_expirytime();
  inline void set_has_creationtimesec();
  inline void clear_has_creationtimesec();
  inline void set_has_maxrenewaldurationsec();
  inline void clear_has_maxrenewaldurationsec();
  inline void set_has_isexternal();
  inline void clear_has_isexternal();

  ::mapr::fs::CredentialsMsg* usercreds_;
  ::mapr::fs::Key* userkey_;
  ::google::protobuf::uint64 expirytime_;
  ::google::protobuf::uint64 creationtimesec_;
  ::google::protobuf::uint64 maxrenewaldurationsec_;
  bool isexternal_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_security_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_security_2eproto();
  #endif
  friend void protobuf_AssignDesc_security_2eproto();
  friend void protobuf_ShutdownFile_security_2eproto();

  void InitAsDefaultInstance();
  static Ticket* default_instance_;
};
// -------------------------------------------------------------------

class TicketAndKey : public ::google::protobuf::MessageLite {
 public:
  TicketAndKey();
  virtual ~TicketAndKey();

  TicketAndKey(const TicketAndKey& from);

  inline TicketAndKey& operator=(const TicketAndKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const TicketAndKey& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TicketAndKey* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TicketAndKey* other);

  // implements Message ----------------------------------------------

  TicketAndKey* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TicketAndKey& from);
  void MergeFrom(const TicketAndKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes encryptedTicket = 1;
  inline bool has_encryptedticket() const;
  inline void clear_encryptedticket();
  static const int kEncryptedTicketFieldNumber = 1;
  inline const ::std::string& encryptedticket() const;
  inline void set_encryptedticket(const ::std::string& value);
  inline void set_encryptedticket(const char* value);
  inline void set_encryptedticket(const void* value, size_t size);
  inline ::std::string* mutable_encryptedticket();
  inline ::std::string* release_encryptedticket();
  inline void set_allocated_encryptedticket(::std::string* encryptedticket);

  // optional .mapr.fs.Key userKey = 2;
  inline bool has_userkey() const;
  inline void clear_userkey();
  static const int kUserKeyFieldNumber = 2;
  inline const ::mapr::fs::Key& userkey() const;
  inline ::mapr::fs::Key* mutable_userkey();
  inline ::mapr::fs::Key* release_userkey();
  inline void set_allocated_userkey(::mapr::fs::Key* userkey);

  // optional .mapr.fs.CredentialsMsg userCreds = 3;
  inline bool has_usercreds() const;
  inline void clear_usercreds();
  static const int kUserCredsFieldNumber = 3;
  inline const ::mapr::fs::CredentialsMsg& usercreds() const;
  inline ::mapr::fs::CredentialsMsg* mutable_usercreds();
  inline ::mapr::fs::CredentialsMsg* release_usercreds();
  inline void set_allocated_usercreds(::mapr::fs::CredentialsMsg* usercreds);

  // optional uint64 expiryTime = 4;
  inline bool has_expirytime() const;
  inline void clear_expirytime();
  static const int kExpiryTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 expirytime() const;
  inline void set_expirytime(::google::protobuf::uint64 value);

  // optional uint64 creationTimeSec = 5;
  inline bool has_creationtimesec() const;
  inline void clear_creationtimesec();
  static const int kCreationTimeSecFieldNumber = 5;
  inline ::google::protobuf::uint64 creationtimesec() const;
  inline void set_creationtimesec(::google::protobuf::uint64 value);

  // optional uint64 maxRenewalDurationSec = 6;
  inline bool has_maxrenewaldurationsec() const;
  inline void clear_maxrenewaldurationsec();
  static const int kMaxRenewalDurationSecFieldNumber = 6;
  inline ::google::protobuf::uint64 maxrenewaldurationsec() const;
  inline void set_maxrenewaldurationsec(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mapr.fs.TicketAndKey)
 private:
  inline void set_has_encryptedticket();
  inline void clear_has_encryptedticket();
  inline void set_has_userkey();
  inline void clear_has_userkey();
  inline void set_has_usercreds();
  inline void clear_has_usercreds();
  inline void set_has_expirytime();
  inline void clear_has_expirytime();
  inline void set_has_creationtimesec();
  inline void clear_has_creationtimesec();
  inline void set_has_maxrenewaldurationsec();
  inline void clear_has_maxrenewaldurationsec();

  ::std::string* encryptedticket_;
  ::mapr::fs::Key* userkey_;
  ::mapr::fs::CredentialsMsg* usercreds_;
  ::google::protobuf::uint64 expirytime_;
  ::google::protobuf::uint64 creationtimesec_;
  ::google::protobuf::uint64 maxrenewaldurationsec_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_security_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_security_2eproto();
  #endif
  friend void protobuf_AssignDesc_security_2eproto();
  friend void protobuf_ShutdownFile_security_2eproto();

  void InitAsDefaultInstance();
  static TicketAndKey* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticationReq : public ::google::protobuf::MessageLite {
 public:
  AuthenticationReq();
  virtual ~AuthenticationReq();

  AuthenticationReq(const AuthenticationReq& from);

  inline AuthenticationReq& operator=(const AuthenticationReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuthenticationReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticationReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticationReq* other);

  // implements Message ----------------------------------------------

  AuthenticationReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticationReq& from);
  void MergeFrom(const AuthenticationReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 challenge = 1;
  inline bool has_challenge() const;
  inline void clear_challenge();
  static const int kChallengeFieldNumber = 1;
  inline ::google::protobuf::uint64 challenge() const;
  inline void set_challenge(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mapr.fs.AuthenticationReq)
 private:
  inline void set_has_challenge();
  inline void clear_has_challenge();

  ::google::protobuf::uint64 challenge_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_security_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_security_2eproto();
  #endif
  friend void protobuf_AssignDesc_security_2eproto();
  friend void protobuf_ShutdownFile_security_2eproto();

  void InitAsDefaultInstance();
  static AuthenticationReq* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticationReqFull : public ::google::protobuf::MessageLite {
 public:
  AuthenticationReqFull();
  virtual ~AuthenticationReqFull();

  AuthenticationReqFull(const AuthenticationReqFull& from);

  inline AuthenticationReqFull& operator=(const AuthenticationReqFull& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuthenticationReqFull& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticationReqFull* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticationReqFull* other);

  // implements Message ----------------------------------------------

  AuthenticationReqFull* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticationReqFull& from);
  void MergeFrom(const AuthenticationReqFull& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes encryptedRandomSecret = 1;
  inline bool has_encryptedrandomsecret() const;
  inline void clear_encryptedrandomsecret();
  static const int kEncryptedRandomSecretFieldNumber = 1;
  inline const ::std::string& encryptedrandomsecret() const;
  inline void set_encryptedrandomsecret(const ::std::string& value);
  inline void set_encryptedrandomsecret(const char* value);
  inline void set_encryptedrandomsecret(const void* value, size_t size);
  inline ::std::string* mutable_encryptedrandomsecret();
  inline ::std::string* release_encryptedrandomsecret();
  inline void set_allocated_encryptedrandomsecret(::std::string* encryptedrandomsecret);

  // optional bytes encryptedTicket = 2;
  inline bool has_encryptedticket() const;
  inline void clear_encryptedticket();
  static const int kEncryptedTicketFieldNumber = 2;
  inline const ::std::string& encryptedticket() const;
  inline void set_encryptedticket(const ::std::string& value);
  inline void set_encryptedticket(const char* value);
  inline void set_encryptedticket(const void* value, size_t size);
  inline ::std::string* mutable_encryptedticket();
  inline ::std::string* release_encryptedticket();
  inline void set_allocated_encryptedticket(::std::string* encryptedticket);

  // @@protoc_insertion_point(class_scope:mapr.fs.AuthenticationReqFull)
 private:
  inline void set_has_encryptedrandomsecret();
  inline void clear_has_encryptedrandomsecret();
  inline void set_has_encryptedticket();
  inline void clear_has_encryptedticket();

  ::std::string* encryptedrandomsecret_;
  ::std::string* encryptedticket_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_security_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_security_2eproto();
  #endif
  friend void protobuf_AssignDesc_security_2eproto();
  friend void protobuf_ShutdownFile_security_2eproto();

  void InitAsDefaultInstance();
  static AuthenticationReqFull* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticationResp : public ::google::protobuf::MessageLite {
 public:
  AuthenticationResp();
  virtual ~AuthenticationResp();

  AuthenticationResp(const AuthenticationResp& from);

  inline AuthenticationResp& operator=(const AuthenticationResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuthenticationResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticationResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticationResp* other);

  // implements Message ----------------------------------------------

  AuthenticationResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticationResp& from);
  void MergeFrom(const AuthenticationResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional uint64 challengeResponse = 2;
  inline bool has_challengeresponse() const;
  inline void clear_challengeresponse();
  static const int kChallengeResponseFieldNumber = 2;
  inline ::google::protobuf::uint64 challengeresponse() const;
  inline void set_challengeresponse(::google::protobuf::uint64 value);

  // optional .mapr.fs.Key sessionKey = 3;
  inline bool has_sessionkey() const;
  inline void clear_sessionkey();
  static const int kSessionKeyFieldNumber = 3;
  inline const ::mapr::fs::Key& sessionkey() const;
  inline ::mapr::fs::Key* mutable_sessionkey();
  inline ::mapr::fs::Key* release_sessionkey();
  inline void set_allocated_sessionkey(::mapr::fs::Key* sessionkey);

  // optional int32 encodingType = 4;
  inline bool has_encodingtype() const;
  inline void clear_encodingtype();
  static const int kEncodingTypeFieldNumber = 4;
  inline ::google::protobuf::int32 encodingtype() const;
  inline void set_encodingtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mapr.fs.AuthenticationResp)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_challengeresponse();
  inline void clear_has_challengeresponse();
  inline void set_has_sessionkey();
  inline void clear_has_sessionkey();
  inline void set_has_encodingtype();
  inline void clear_has_encodingtype();

  ::google::protobuf::uint64 challengeresponse_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 encodingtype_;
  ::mapr::fs::Key* sessionkey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_security_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_security_2eproto();
  #endif
  friend void protobuf_AssignDesc_security_2eproto();
  friend void protobuf_ShutdownFile_security_2eproto();

  void InitAsDefaultInstance();
  static AuthenticationResp* default_instance_;
};
// -------------------------------------------------------------------

class TicketDescriptor : public ::google::protobuf::MessageLite {
 public:
  TicketDescriptor();
  virtual ~TicketDescriptor();

  TicketDescriptor(const TicketDescriptor& from);

  inline TicketDescriptor& operator=(const TicketDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  static const TicketDescriptor& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TicketDescriptor* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TicketDescriptor* other);

  // implements Message ----------------------------------------------

  TicketDescriptor* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TicketDescriptor& from);
  void MergeFrom(const TicketDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mapr.fs.ServerKeyType keyType = 1;
  inline bool has_keytype() const;
  inline void clear_keytype();
  static const int kKeyTypeFieldNumber = 1;
  inline ::mapr::fs::ServerKeyType keytype() const;
  inline void set_keytype(::mapr::fs::ServerKeyType value);

  // @@protoc_insertion_point(class_scope:mapr.fs.TicketDescriptor)
 private:
  inline void set_has_keytype();
  inline void clear_has_keytype();

  int keytype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_security_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_security_2eproto();
  #endif
  friend void protobuf_AssignDesc_security_2eproto();
  friend void protobuf_ShutdownFile_security_2eproto();

  void InitAsDefaultInstance();
  static TicketDescriptor* default_instance_;
};
// ===================================================================


// ===================================================================

// CredentialsMsg

// optional uint32 uid = 1;
inline bool CredentialsMsg::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CredentialsMsg::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CredentialsMsg::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CredentialsMsg::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 CredentialsMsg::uid() const {
  return uid_;
}
inline void CredentialsMsg::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// repeated uint32 gids = 2;
inline int CredentialsMsg::gids_size() const {
  return gids_.size();
}
inline void CredentialsMsg::clear_gids() {
  gids_.Clear();
}
inline ::google::protobuf::uint32 CredentialsMsg::gids(int index) const {
  return gids_.Get(index);
}
inline void CredentialsMsg::set_gids(int index, ::google::protobuf::uint32 value) {
  gids_.Set(index, value);
}
inline void CredentialsMsg::add_gids(::google::protobuf::uint32 value) {
  gids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CredentialsMsg::gids() const {
  return gids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CredentialsMsg::mutable_gids() {
  return &gids_;
}

// optional bool isRoot = 3;
inline bool CredentialsMsg::has_isroot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CredentialsMsg::set_has_isroot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CredentialsMsg::clear_has_isroot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CredentialsMsg::clear_isroot() {
  isroot_ = false;
  clear_has_isroot();
}
inline bool CredentialsMsg::isroot() const {
  return isroot_;
}
inline void CredentialsMsg::set_isroot(bool value) {
  set_has_isroot();
  isroot_ = value;
}

// optional string userName = 4;
inline bool CredentialsMsg::has_username() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CredentialsMsg::set_has_username() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CredentialsMsg::clear_has_username() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CredentialsMsg::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& CredentialsMsg::username() const {
  return *username_;
}
inline void CredentialsMsg::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void CredentialsMsg::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void CredentialsMsg::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CredentialsMsg::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* CredentialsMsg::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CredentialsMsg::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SecurityPrincipal

// optional uint32 princId = 1;
inline bool SecurityPrincipal::has_princid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityPrincipal::set_has_princid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityPrincipal::clear_has_princid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityPrincipal::clear_princid() {
  princid_ = 0u;
  clear_has_princid();
}
inline ::google::protobuf::uint32 SecurityPrincipal::princid() const {
  return princid_;
}
inline void SecurityPrincipal::set_princid(::google::protobuf::uint32 value) {
  set_has_princid();
  princid_ = value;
}

// -------------------------------------------------------------------

// AclEntry

// required .mapr.fs.SecurityPrincipal principal = 1;
inline bool AclEntry::has_principal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AclEntry::set_has_principal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AclEntry::clear_has_principal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AclEntry::clear_principal() {
  if (principal_ != NULL) principal_->::mapr::fs::SecurityPrincipal::Clear();
  clear_has_principal();
}
inline const ::mapr::fs::SecurityPrincipal& AclEntry::principal() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return principal_ != NULL ? *principal_ : *default_instance().principal_;
#else
  return principal_ != NULL ? *principal_ : *default_instance_->principal_;
#endif
}
inline ::mapr::fs::SecurityPrincipal* AclEntry::mutable_principal() {
  set_has_principal();
  if (principal_ == NULL) principal_ = new ::mapr::fs::SecurityPrincipal;
  return principal_;
}
inline ::mapr::fs::SecurityPrincipal* AclEntry::release_principal() {
  clear_has_principal();
  ::mapr::fs::SecurityPrincipal* temp = principal_;
  principal_ = NULL;
  return temp;
}
inline void AclEntry::set_allocated_principal(::mapr::fs::SecurityPrincipal* principal) {
  delete principal_;
  principal_ = principal;
  if (principal) {
    set_has_principal();
  } else {
    clear_has_principal();
  }
}

// optional uint32 allow = 2;
inline bool AclEntry::has_allow() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AclEntry::set_has_allow() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AclEntry::clear_has_allow() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AclEntry::clear_allow() {
  allow_ = 0u;
  clear_has_allow();
}
inline ::google::protobuf::uint32 AclEntry::allow() const {
  return allow_;
}
inline void AclEntry::set_allow(::google::protobuf::uint32 value) {
  set_has_allow();
  allow_ = value;
}

// optional uint32 deny = 3;
inline bool AclEntry::has_deny() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AclEntry::set_has_deny() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AclEntry::clear_has_deny() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AclEntry::clear_deny() {
  deny_ = 0u;
  clear_has_deny();
}
inline ::google::protobuf::uint32 AclEntry::deny() const {
  return deny_;
}
inline void AclEntry::set_deny(::google::protobuf::uint32 value) {
  set_has_deny();
  deny_ = value;
}

// -------------------------------------------------------------------

// AccessControlList

// repeated .mapr.fs.AclEntry acl = 1;
inline int AccessControlList::acl_size() const {
  return acl_.size();
}
inline void AccessControlList::clear_acl() {
  acl_.Clear();
}
inline const ::mapr::fs::AclEntry& AccessControlList::acl(int index) const {
  return acl_.Get(index);
}
inline ::mapr::fs::AclEntry* AccessControlList::mutable_acl(int index) {
  return acl_.Mutable(index);
}
inline ::mapr::fs::AclEntry* AccessControlList::add_acl() {
  return acl_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mapr::fs::AclEntry >&
AccessControlList::acl() const {
  return acl_;
}
inline ::google::protobuf::RepeatedPtrField< ::mapr::fs::AclEntry >*
AccessControlList::mutable_acl() {
  return &acl_;
}

// -------------------------------------------------------------------

// Key

// optional bytes key = 1;
inline bool Key::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Key::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Key::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Key::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Key::key() const {
  return *key_;
}
inline void Key::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Key::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Key::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Key::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Key::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Key::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Ticket

// optional .mapr.fs.CredentialsMsg userCreds = 1;
inline bool Ticket::has_usercreds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ticket::set_has_usercreds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ticket::clear_has_usercreds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ticket::clear_usercreds() {
  if (usercreds_ != NULL) usercreds_->::mapr::fs::CredentialsMsg::Clear();
  clear_has_usercreds();
}
inline const ::mapr::fs::CredentialsMsg& Ticket::usercreds() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return usercreds_ != NULL ? *usercreds_ : *default_instance().usercreds_;
#else
  return usercreds_ != NULL ? *usercreds_ : *default_instance_->usercreds_;
#endif
}
inline ::mapr::fs::CredentialsMsg* Ticket::mutable_usercreds() {
  set_has_usercreds();
  if (usercreds_ == NULL) usercreds_ = new ::mapr::fs::CredentialsMsg;
  return usercreds_;
}
inline ::mapr::fs::CredentialsMsg* Ticket::release_usercreds() {
  clear_has_usercreds();
  ::mapr::fs::CredentialsMsg* temp = usercreds_;
  usercreds_ = NULL;
  return temp;
}
inline void Ticket::set_allocated_usercreds(::mapr::fs::CredentialsMsg* usercreds) {
  delete usercreds_;
  usercreds_ = usercreds;
  if (usercreds) {
    set_has_usercreds();
  } else {
    clear_has_usercreds();
  }
}

// optional .mapr.fs.Key userKey = 2;
inline bool Ticket::has_userkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ticket::set_has_userkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ticket::clear_has_userkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ticket::clear_userkey() {
  if (userkey_ != NULL) userkey_->::mapr::fs::Key::Clear();
  clear_has_userkey();
}
inline const ::mapr::fs::Key& Ticket::userkey() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return userkey_ != NULL ? *userkey_ : *default_instance().userkey_;
#else
  return userkey_ != NULL ? *userkey_ : *default_instance_->userkey_;
#endif
}
inline ::mapr::fs::Key* Ticket::mutable_userkey() {
  set_has_userkey();
  if (userkey_ == NULL) userkey_ = new ::mapr::fs::Key;
  return userkey_;
}
inline ::mapr::fs::Key* Ticket::release_userkey() {
  clear_has_userkey();
  ::mapr::fs::Key* temp = userkey_;
  userkey_ = NULL;
  return temp;
}
inline void Ticket::set_allocated_userkey(::mapr::fs::Key* userkey) {
  delete userkey_;
  userkey_ = userkey;
  if (userkey) {
    set_has_userkey();
  } else {
    clear_has_userkey();
  }
}

// optional uint64 expiryTime = 3;
inline bool Ticket::has_expirytime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ticket::set_has_expirytime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ticket::clear_has_expirytime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ticket::clear_expirytime() {
  expirytime_ = GOOGLE_ULONGLONG(0);
  clear_has_expirytime();
}
inline ::google::protobuf::uint64 Ticket::expirytime() const {
  return expirytime_;
}
inline void Ticket::set_expirytime(::google::protobuf::uint64 value) {
  set_has_expirytime();
  expirytime_ = value;
}

// optional uint64 creationTimeSec = 4;
inline bool Ticket::has_creationtimesec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ticket::set_has_creationtimesec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ticket::clear_has_creationtimesec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ticket::clear_creationtimesec() {
  creationtimesec_ = GOOGLE_ULONGLONG(0);
  clear_has_creationtimesec();
}
inline ::google::protobuf::uint64 Ticket::creationtimesec() const {
  return creationtimesec_;
}
inline void Ticket::set_creationtimesec(::google::protobuf::uint64 value) {
  set_has_creationtimesec();
  creationtimesec_ = value;
}

// optional uint64 maxRenewalDurationSec = 5;
inline bool Ticket::has_maxrenewaldurationsec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ticket::set_has_maxrenewaldurationsec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ticket::clear_has_maxrenewaldurationsec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ticket::clear_maxrenewaldurationsec() {
  maxrenewaldurationsec_ = GOOGLE_ULONGLONG(0);
  clear_has_maxrenewaldurationsec();
}
inline ::google::protobuf::uint64 Ticket::maxrenewaldurationsec() const {
  return maxrenewaldurationsec_;
}
inline void Ticket::set_maxrenewaldurationsec(::google::protobuf::uint64 value) {
  set_has_maxrenewaldurationsec();
  maxrenewaldurationsec_ = value;
}

// optional bool isExternal = 6;
inline bool Ticket::has_isexternal() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Ticket::set_has_isexternal() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Ticket::clear_has_isexternal() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Ticket::clear_isexternal() {
  isexternal_ = false;
  clear_has_isexternal();
}
inline bool Ticket::isexternal() const {
  return isexternal_;
}
inline void Ticket::set_isexternal(bool value) {
  set_has_isexternal();
  isexternal_ = value;
}

// -------------------------------------------------------------------

// TicketAndKey

// optional bytes encryptedTicket = 1;
inline bool TicketAndKey::has_encryptedticket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TicketAndKey::set_has_encryptedticket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TicketAndKey::clear_has_encryptedticket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TicketAndKey::clear_encryptedticket() {
  if (encryptedticket_ != &::google::protobuf::internal::kEmptyString) {
    encryptedticket_->clear();
  }
  clear_has_encryptedticket();
}
inline const ::std::string& TicketAndKey::encryptedticket() const {
  return *encryptedticket_;
}
inline void TicketAndKey::set_encryptedticket(const ::std::string& value) {
  set_has_encryptedticket();
  if (encryptedticket_ == &::google::protobuf::internal::kEmptyString) {
    encryptedticket_ = new ::std::string;
  }
  encryptedticket_->assign(value);
}
inline void TicketAndKey::set_encryptedticket(const char* value) {
  set_has_encryptedticket();
  if (encryptedticket_ == &::google::protobuf::internal::kEmptyString) {
    encryptedticket_ = new ::std::string;
  }
  encryptedticket_->assign(value);
}
inline void TicketAndKey::set_encryptedticket(const void* value, size_t size) {
  set_has_encryptedticket();
  if (encryptedticket_ == &::google::protobuf::internal::kEmptyString) {
    encryptedticket_ = new ::std::string;
  }
  encryptedticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TicketAndKey::mutable_encryptedticket() {
  set_has_encryptedticket();
  if (encryptedticket_ == &::google::protobuf::internal::kEmptyString) {
    encryptedticket_ = new ::std::string;
  }
  return encryptedticket_;
}
inline ::std::string* TicketAndKey::release_encryptedticket() {
  clear_has_encryptedticket();
  if (encryptedticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedticket_;
    encryptedticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TicketAndKey::set_allocated_encryptedticket(::std::string* encryptedticket) {
  if (encryptedticket_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedticket_;
  }
  if (encryptedticket) {
    set_has_encryptedticket();
    encryptedticket_ = encryptedticket;
  } else {
    clear_has_encryptedticket();
    encryptedticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mapr.fs.Key userKey = 2;
inline bool TicketAndKey::has_userkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TicketAndKey::set_has_userkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TicketAndKey::clear_has_userkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TicketAndKey::clear_userkey() {
  if (userkey_ != NULL) userkey_->::mapr::fs::Key::Clear();
  clear_has_userkey();
}
inline const ::mapr::fs::Key& TicketAndKey::userkey() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return userkey_ != NULL ? *userkey_ : *default_instance().userkey_;
#else
  return userkey_ != NULL ? *userkey_ : *default_instance_->userkey_;
#endif
}
inline ::mapr::fs::Key* TicketAndKey::mutable_userkey() {
  set_has_userkey();
  if (userkey_ == NULL) userkey_ = new ::mapr::fs::Key;
  return userkey_;
}
inline ::mapr::fs::Key* TicketAndKey::release_userkey() {
  clear_has_userkey();
  ::mapr::fs::Key* temp = userkey_;
  userkey_ = NULL;
  return temp;
}
inline void TicketAndKey::set_allocated_userkey(::mapr::fs::Key* userkey) {
  delete userkey_;
  userkey_ = userkey;
  if (userkey) {
    set_has_userkey();
  } else {
    clear_has_userkey();
  }
}

// optional .mapr.fs.CredentialsMsg userCreds = 3;
inline bool TicketAndKey::has_usercreds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TicketAndKey::set_has_usercreds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TicketAndKey::clear_has_usercreds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TicketAndKey::clear_usercreds() {
  if (usercreds_ != NULL) usercreds_->::mapr::fs::CredentialsMsg::Clear();
  clear_has_usercreds();
}
inline const ::mapr::fs::CredentialsMsg& TicketAndKey::usercreds() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return usercreds_ != NULL ? *usercreds_ : *default_instance().usercreds_;
#else
  return usercreds_ != NULL ? *usercreds_ : *default_instance_->usercreds_;
#endif
}
inline ::mapr::fs::CredentialsMsg* TicketAndKey::mutable_usercreds() {
  set_has_usercreds();
  if (usercreds_ == NULL) usercreds_ = new ::mapr::fs::CredentialsMsg;
  return usercreds_;
}
inline ::mapr::fs::CredentialsMsg* TicketAndKey::release_usercreds() {
  clear_has_usercreds();
  ::mapr::fs::CredentialsMsg* temp = usercreds_;
  usercreds_ = NULL;
  return temp;
}
inline void TicketAndKey::set_allocated_usercreds(::mapr::fs::CredentialsMsg* usercreds) {
  delete usercreds_;
  usercreds_ = usercreds;
  if (usercreds) {
    set_has_usercreds();
  } else {
    clear_has_usercreds();
  }
}

// optional uint64 expiryTime = 4;
inline bool TicketAndKey::has_expirytime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TicketAndKey::set_has_expirytime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TicketAndKey::clear_has_expirytime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TicketAndKey::clear_expirytime() {
  expirytime_ = GOOGLE_ULONGLONG(0);
  clear_has_expirytime();
}
inline ::google::protobuf::uint64 TicketAndKey::expirytime() const {
  return expirytime_;
}
inline void TicketAndKey::set_expirytime(::google::protobuf::uint64 value) {
  set_has_expirytime();
  expirytime_ = value;
}

// optional uint64 creationTimeSec = 5;
inline bool TicketAndKey::has_creationtimesec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TicketAndKey::set_has_creationtimesec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TicketAndKey::clear_has_creationtimesec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TicketAndKey::clear_creationtimesec() {
  creationtimesec_ = GOOGLE_ULONGLONG(0);
  clear_has_creationtimesec();
}
inline ::google::protobuf::uint64 TicketAndKey::creationtimesec() const {
  return creationtimesec_;
}
inline void TicketAndKey::set_creationtimesec(::google::protobuf::uint64 value) {
  set_has_creationtimesec();
  creationtimesec_ = value;
}

// optional uint64 maxRenewalDurationSec = 6;
inline bool TicketAndKey::has_maxrenewaldurationsec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TicketAndKey::set_has_maxrenewaldurationsec() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TicketAndKey::clear_has_maxrenewaldurationsec() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TicketAndKey::clear_maxrenewaldurationsec() {
  maxrenewaldurationsec_ = GOOGLE_ULONGLONG(0);
  clear_has_maxrenewaldurationsec();
}
inline ::google::protobuf::uint64 TicketAndKey::maxrenewaldurationsec() const {
  return maxrenewaldurationsec_;
}
inline void TicketAndKey::set_maxrenewaldurationsec(::google::protobuf::uint64 value) {
  set_has_maxrenewaldurationsec();
  maxrenewaldurationsec_ = value;
}

// -------------------------------------------------------------------

// AuthenticationReq

// optional uint64 challenge = 1;
inline bool AuthenticationReq::has_challenge() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticationReq::set_has_challenge() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticationReq::clear_has_challenge() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticationReq::clear_challenge() {
  challenge_ = GOOGLE_ULONGLONG(0);
  clear_has_challenge();
}
inline ::google::protobuf::uint64 AuthenticationReq::challenge() const {
  return challenge_;
}
inline void AuthenticationReq::set_challenge(::google::protobuf::uint64 value) {
  set_has_challenge();
  challenge_ = value;
}

// -------------------------------------------------------------------

// AuthenticationReqFull

// optional bytes encryptedRandomSecret = 1;
inline bool AuthenticationReqFull::has_encryptedrandomsecret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticationReqFull::set_has_encryptedrandomsecret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticationReqFull::clear_has_encryptedrandomsecret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticationReqFull::clear_encryptedrandomsecret() {
  if (encryptedrandomsecret_ != &::google::protobuf::internal::kEmptyString) {
    encryptedrandomsecret_->clear();
  }
  clear_has_encryptedrandomsecret();
}
inline const ::std::string& AuthenticationReqFull::encryptedrandomsecret() const {
  return *encryptedrandomsecret_;
}
inline void AuthenticationReqFull::set_encryptedrandomsecret(const ::std::string& value) {
  set_has_encryptedrandomsecret();
  if (encryptedrandomsecret_ == &::google::protobuf::internal::kEmptyString) {
    encryptedrandomsecret_ = new ::std::string;
  }
  encryptedrandomsecret_->assign(value);
}
inline void AuthenticationReqFull::set_encryptedrandomsecret(const char* value) {
  set_has_encryptedrandomsecret();
  if (encryptedrandomsecret_ == &::google::protobuf::internal::kEmptyString) {
    encryptedrandomsecret_ = new ::std::string;
  }
  encryptedrandomsecret_->assign(value);
}
inline void AuthenticationReqFull::set_encryptedrandomsecret(const void* value, size_t size) {
  set_has_encryptedrandomsecret();
  if (encryptedrandomsecret_ == &::google::protobuf::internal::kEmptyString) {
    encryptedrandomsecret_ = new ::std::string;
  }
  encryptedrandomsecret_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticationReqFull::mutable_encryptedrandomsecret() {
  set_has_encryptedrandomsecret();
  if (encryptedrandomsecret_ == &::google::protobuf::internal::kEmptyString) {
    encryptedrandomsecret_ = new ::std::string;
  }
  return encryptedrandomsecret_;
}
inline ::std::string* AuthenticationReqFull::release_encryptedrandomsecret() {
  clear_has_encryptedrandomsecret();
  if (encryptedrandomsecret_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedrandomsecret_;
    encryptedrandomsecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthenticationReqFull::set_allocated_encryptedrandomsecret(::std::string* encryptedrandomsecret) {
  if (encryptedrandomsecret_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedrandomsecret_;
  }
  if (encryptedrandomsecret) {
    set_has_encryptedrandomsecret();
    encryptedrandomsecret_ = encryptedrandomsecret;
  } else {
    clear_has_encryptedrandomsecret();
    encryptedrandomsecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encryptedTicket = 2;
inline bool AuthenticationReqFull::has_encryptedticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticationReqFull::set_has_encryptedticket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticationReqFull::clear_has_encryptedticket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticationReqFull::clear_encryptedticket() {
  if (encryptedticket_ != &::google::protobuf::internal::kEmptyString) {
    encryptedticket_->clear();
  }
  clear_has_encryptedticket();
}
inline const ::std::string& AuthenticationReqFull::encryptedticket() const {
  return *encryptedticket_;
}
inline void AuthenticationReqFull::set_encryptedticket(const ::std::string& value) {
  set_has_encryptedticket();
  if (encryptedticket_ == &::google::protobuf::internal::kEmptyString) {
    encryptedticket_ = new ::std::string;
  }
  encryptedticket_->assign(value);
}
inline void AuthenticationReqFull::set_encryptedticket(const char* value) {
  set_has_encryptedticket();
  if (encryptedticket_ == &::google::protobuf::internal::kEmptyString) {
    encryptedticket_ = new ::std::string;
  }
  encryptedticket_->assign(value);
}
inline void AuthenticationReqFull::set_encryptedticket(const void* value, size_t size) {
  set_has_encryptedticket();
  if (encryptedticket_ == &::google::protobuf::internal::kEmptyString) {
    encryptedticket_ = new ::std::string;
  }
  encryptedticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticationReqFull::mutable_encryptedticket() {
  set_has_encryptedticket();
  if (encryptedticket_ == &::google::protobuf::internal::kEmptyString) {
    encryptedticket_ = new ::std::string;
  }
  return encryptedticket_;
}
inline ::std::string* AuthenticationReqFull::release_encryptedticket() {
  clear_has_encryptedticket();
  if (encryptedticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptedticket_;
    encryptedticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthenticationReqFull::set_allocated_encryptedticket(::std::string* encryptedticket) {
  if (encryptedticket_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedticket_;
  }
  if (encryptedticket) {
    set_has_encryptedticket();
    encryptedticket_ = encryptedticket;
  } else {
    clear_has_encryptedticket();
    encryptedticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AuthenticationResp

// optional int32 status = 1;
inline bool AuthenticationResp::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticationResp::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticationResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticationResp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 AuthenticationResp::status() const {
  return status_;
}
inline void AuthenticationResp::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional uint64 challengeResponse = 2;
inline bool AuthenticationResp::has_challengeresponse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticationResp::set_has_challengeresponse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticationResp::clear_has_challengeresponse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticationResp::clear_challengeresponse() {
  challengeresponse_ = GOOGLE_ULONGLONG(0);
  clear_has_challengeresponse();
}
inline ::google::protobuf::uint64 AuthenticationResp::challengeresponse() const {
  return challengeresponse_;
}
inline void AuthenticationResp::set_challengeresponse(::google::protobuf::uint64 value) {
  set_has_challengeresponse();
  challengeresponse_ = value;
}

// optional .mapr.fs.Key sessionKey = 3;
inline bool AuthenticationResp::has_sessionkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthenticationResp::set_has_sessionkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthenticationResp::clear_has_sessionkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthenticationResp::clear_sessionkey() {
  if (sessionkey_ != NULL) sessionkey_->::mapr::fs::Key::Clear();
  clear_has_sessionkey();
}
inline const ::mapr::fs::Key& AuthenticationResp::sessionkey() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sessionkey_ != NULL ? *sessionkey_ : *default_instance().sessionkey_;
#else
  return sessionkey_ != NULL ? *sessionkey_ : *default_instance_->sessionkey_;
#endif
}
inline ::mapr::fs::Key* AuthenticationResp::mutable_sessionkey() {
  set_has_sessionkey();
  if (sessionkey_ == NULL) sessionkey_ = new ::mapr::fs::Key;
  return sessionkey_;
}
inline ::mapr::fs::Key* AuthenticationResp::release_sessionkey() {
  clear_has_sessionkey();
  ::mapr::fs::Key* temp = sessionkey_;
  sessionkey_ = NULL;
  return temp;
}
inline void AuthenticationResp::set_allocated_sessionkey(::mapr::fs::Key* sessionkey) {
  delete sessionkey_;
  sessionkey_ = sessionkey;
  if (sessionkey) {
    set_has_sessionkey();
  } else {
    clear_has_sessionkey();
  }
}

// optional int32 encodingType = 4;
inline bool AuthenticationResp::has_encodingtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AuthenticationResp::set_has_encodingtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AuthenticationResp::clear_has_encodingtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AuthenticationResp::clear_encodingtype() {
  encodingtype_ = 0;
  clear_has_encodingtype();
}
inline ::google::protobuf::int32 AuthenticationResp::encodingtype() const {
  return encodingtype_;
}
inline void AuthenticationResp::set_encodingtype(::google::protobuf::int32 value) {
  set_has_encodingtype();
  encodingtype_ = value;
}

// -------------------------------------------------------------------

// TicketDescriptor

// optional .mapr.fs.ServerKeyType keyType = 1;
inline bool TicketDescriptor::has_keytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TicketDescriptor::set_has_keytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TicketDescriptor::clear_has_keytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TicketDescriptor::clear_keytype() {
  keytype_ = 0;
  clear_has_keytype();
}
inline ::mapr::fs::ServerKeyType TicketDescriptor::keytype() const {
  return static_cast< ::mapr::fs::ServerKeyType >(keytype_);
}
inline void TicketDescriptor::set_keytype(::mapr::fs::ServerKeyType value) {
  assert(::mapr::fs::ServerKeyType_IsValid(value));
  set_has_keytype();
  keytype_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fs
}  // namespace mapr

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_security_2eproto__INCLUDED
