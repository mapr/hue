// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: security.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "security.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace mapr {
namespace fs {

void protobuf_ShutdownFile_security_2eproto() {
  delete CredentialsMsg::default_instance_;
  delete SecurityPrincipal::default_instance_;
  delete AclEntry::default_instance_;
  delete AccessControlList::default_instance_;
  delete Key::default_instance_;
  delete Ticket::default_instance_;
  delete TicketAndKey::default_instance_;
  delete AuthenticationReq::default_instance_;
  delete AuthenticationReqFull::default_instance_;
  delete AuthenticationResp::default_instance_;
  delete TicketDescriptor::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_security_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_security_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  CredentialsMsg::default_instance_ = new CredentialsMsg();
  SecurityPrincipal::default_instance_ = new SecurityPrincipal();
  AclEntry::default_instance_ = new AclEntry();
  AccessControlList::default_instance_ = new AccessControlList();
  Key::default_instance_ = new Key();
  Ticket::default_instance_ = new Ticket();
  TicketAndKey::default_instance_ = new TicketAndKey();
  AuthenticationReq::default_instance_ = new AuthenticationReq();
  AuthenticationReqFull::default_instance_ = new AuthenticationReqFull();
  AuthenticationResp::default_instance_ = new AuthenticationResp();
  TicketDescriptor::default_instance_ = new TicketDescriptor();
  CredentialsMsg::default_instance_->InitAsDefaultInstance();
  SecurityPrincipal::default_instance_->InitAsDefaultInstance();
  AclEntry::default_instance_->InitAsDefaultInstance();
  AccessControlList::default_instance_->InitAsDefaultInstance();
  Key::default_instance_->InitAsDefaultInstance();
  Ticket::default_instance_->InitAsDefaultInstance();
  TicketAndKey::default_instance_->InitAsDefaultInstance();
  AuthenticationReq::default_instance_->InitAsDefaultInstance();
  AuthenticationReqFull::default_instance_->InitAsDefaultInstance();
  AuthenticationResp::default_instance_->InitAsDefaultInstance();
  TicketDescriptor::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_security_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_security_2eproto_once_);
void protobuf_AddDesc_security_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_security_2eproto_once_,
                 &protobuf_AddDesc_security_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_security_2eproto {
  StaticDescriptorInitializer_security_2eproto() {
    protobuf_AddDesc_security_2eproto();
  }
} static_descriptor_initializer_security_2eproto_;
#endif
bool SecurityProg_IsValid(int value) {
  switch(value) {
    case 1:
      return true;
    default:
      return false;
  }
}

bool ServerKeyType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int CredentialsMsg::kUidFieldNumber;
const int CredentialsMsg::kGidsFieldNumber;
const int CredentialsMsg::kIsRootFieldNumber;
const int CredentialsMsg::kUserNameFieldNumber;
#endif  // !_MSC_VER

CredentialsMsg::CredentialsMsg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CredentialsMsg::InitAsDefaultInstance() {
}

CredentialsMsg::CredentialsMsg(const CredentialsMsg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CredentialsMsg::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0u;
  isroot_ = false;
  username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CredentialsMsg::~CredentialsMsg() {
  SharedDtor();
}

void CredentialsMsg::SharedDtor() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CredentialsMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CredentialsMsg& CredentialsMsg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_security_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_security_2eproto();
#endif
  return *default_instance_;
}

CredentialsMsg* CredentialsMsg::default_instance_ = NULL;

CredentialsMsg* CredentialsMsg::New() const {
  return new CredentialsMsg;
}

void CredentialsMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0u;
    isroot_ = false;
    if (has_username()) {
      if (username_ != &::google::protobuf::internal::kEmptyString) {
        username_->clear();
      }
    }
  }
  gids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CredentialsMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_gids;
        break;
      }

      // repeated uint32 gids = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_gids())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_gids())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_gids;
        if (input->ExpectTag(24)) goto parse_isRoot;
        break;
      }

      // optional bool isRoot = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isRoot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isroot_)));
          set_has_isroot();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_userName;
        break;
      }

      // optional string userName = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_userName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_username()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CredentialsMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uid(), output);
  }

  // repeated uint32 gids = 2;
  for (int i = 0; i < this->gids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->gids(i), output);
  }

  // optional bool isRoot = 3;
  if (has_isroot()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->isroot(), output);
  }

  // optional string userName = 4;
  if (has_username()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->username(), output);
  }

}

int CredentialsMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uid());
    }

    // optional bool isRoot = 3;
    if (has_isroot()) {
      total_size += 1 + 1;
    }

    // optional string userName = 4;
    if (has_username()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->username());
    }

  }
  // repeated uint32 gids = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->gids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->gids(i));
    }
    total_size += 1 * this->gids_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CredentialsMsg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CredentialsMsg*>(&from));
}

void CredentialsMsg::MergeFrom(const CredentialsMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  gids_.MergeFrom(from.gids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_isroot()) {
      set_isroot(from.isroot());
    }
    if (from.has_username()) {
      set_username(from.username());
    }
  }
}

void CredentialsMsg::CopyFrom(const CredentialsMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CredentialsMsg::IsInitialized() const {

  return true;
}

void CredentialsMsg::Swap(CredentialsMsg* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    gids_.Swap(&other->gids_);
    std::swap(isroot_, other->isroot_);
    std::swap(username_, other->username_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CredentialsMsg::GetTypeName() const {
  return "mapr.fs.CredentialsMsg";
}


// ===================================================================

#ifndef _MSC_VER
const int SecurityPrincipal::kPrincIdFieldNumber;
#endif  // !_MSC_VER

SecurityPrincipal::SecurityPrincipal()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SecurityPrincipal::InitAsDefaultInstance() {
}

SecurityPrincipal::SecurityPrincipal(const SecurityPrincipal& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SecurityPrincipal::SharedCtor() {
  _cached_size_ = 0;
  princid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SecurityPrincipal::~SecurityPrincipal() {
  SharedDtor();
}

void SecurityPrincipal::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SecurityPrincipal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SecurityPrincipal& SecurityPrincipal::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_security_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_security_2eproto();
#endif
  return *default_instance_;
}

SecurityPrincipal* SecurityPrincipal::default_instance_ = NULL;

SecurityPrincipal* SecurityPrincipal::New() const {
  return new SecurityPrincipal;
}

void SecurityPrincipal::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    princid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SecurityPrincipal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 princId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &princid_)));
          set_has_princid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SecurityPrincipal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 princId = 1;
  if (has_princid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->princid(), output);
  }

}

int SecurityPrincipal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 princId = 1;
    if (has_princid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->princid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SecurityPrincipal::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SecurityPrincipal*>(&from));
}

void SecurityPrincipal::MergeFrom(const SecurityPrincipal& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_princid()) {
      set_princid(from.princid());
    }
  }
}

void SecurityPrincipal::CopyFrom(const SecurityPrincipal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecurityPrincipal::IsInitialized() const {

  return true;
}

void SecurityPrincipal::Swap(SecurityPrincipal* other) {
  if (other != this) {
    std::swap(princid_, other->princid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SecurityPrincipal::GetTypeName() const {
  return "mapr.fs.SecurityPrincipal";
}


// ===================================================================

#ifndef _MSC_VER
const int AclEntry::kPrincipalFieldNumber;
const int AclEntry::kAllowFieldNumber;
const int AclEntry::kDenyFieldNumber;
#endif  // !_MSC_VER

AclEntry::AclEntry()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AclEntry::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  principal_ = const_cast< ::mapr::fs::SecurityPrincipal*>(
      ::mapr::fs::SecurityPrincipal::internal_default_instance());
#else
  principal_ = const_cast< ::mapr::fs::SecurityPrincipal*>(&::mapr::fs::SecurityPrincipal::default_instance());
#endif
}

AclEntry::AclEntry(const AclEntry& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AclEntry::SharedCtor() {
  _cached_size_ = 0;
  principal_ = NULL;
  allow_ = 0u;
  deny_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AclEntry::~AclEntry() {
  SharedDtor();
}

void AclEntry::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete principal_;
  }
}

void AclEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AclEntry& AclEntry::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_security_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_security_2eproto();
#endif
  return *default_instance_;
}

AclEntry* AclEntry::default_instance_ = NULL;

AclEntry* AclEntry::New() const {
  return new AclEntry;
}

void AclEntry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_principal()) {
      if (principal_ != NULL) principal_->::mapr::fs::SecurityPrincipal::Clear();
    }
    allow_ = 0u;
    deny_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AclEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mapr.fs.SecurityPrincipal principal = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_principal()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_allow;
        break;
      }

      // optional uint32 allow = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_allow:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &allow_)));
          set_has_allow();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_deny;
        break;
      }

      // optional uint32 deny = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_deny:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &deny_)));
          set_has_deny();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AclEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mapr.fs.SecurityPrincipal principal = 1;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->principal(), output);
  }

  // optional uint32 allow = 2;
  if (has_allow()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->allow(), output);
  }

  // optional uint32 deny = 3;
  if (has_deny()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->deny(), output);
  }

}

int AclEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mapr.fs.SecurityPrincipal principal = 1;
    if (has_principal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->principal());
    }

    // optional uint32 allow = 2;
    if (has_allow()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->allow());
    }

    // optional uint32 deny = 3;
    if (has_deny()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->deny());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AclEntry::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AclEntry*>(&from));
}

void AclEntry::MergeFrom(const AclEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_principal()) {
      mutable_principal()->::mapr::fs::SecurityPrincipal::MergeFrom(from.principal());
    }
    if (from.has_allow()) {
      set_allow(from.allow());
    }
    if (from.has_deny()) {
      set_deny(from.deny());
    }
  }
}

void AclEntry::CopyFrom(const AclEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AclEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AclEntry::Swap(AclEntry* other) {
  if (other != this) {
    std::swap(principal_, other->principal_);
    std::swap(allow_, other->allow_);
    std::swap(deny_, other->deny_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AclEntry::GetTypeName() const {
  return "mapr.fs.AclEntry";
}


// ===================================================================

#ifndef _MSC_VER
const int AccessControlList::kAclFieldNumber;
#endif  // !_MSC_VER

AccessControlList::AccessControlList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AccessControlList::InitAsDefaultInstance() {
}

AccessControlList::AccessControlList(const AccessControlList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AccessControlList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AccessControlList::~AccessControlList() {
  SharedDtor();
}

void AccessControlList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AccessControlList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AccessControlList& AccessControlList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_security_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_security_2eproto();
#endif
  return *default_instance_;
}

AccessControlList* AccessControlList::default_instance_ = NULL;

AccessControlList* AccessControlList::New() const {
  return new AccessControlList;
}

void AccessControlList::Clear() {
  acl_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AccessControlList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mapr.fs.AclEntry acl = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_acl:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_acl()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_acl;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AccessControlList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .mapr.fs.AclEntry acl = 1;
  for (int i = 0; i < this->acl_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->acl(i), output);
  }

}

int AccessControlList::ByteSize() const {
  int total_size = 0;

  // repeated .mapr.fs.AclEntry acl = 1;
  total_size += 1 * this->acl_size();
  for (int i = 0; i < this->acl_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->acl(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AccessControlList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AccessControlList*>(&from));
}

void AccessControlList::MergeFrom(const AccessControlList& from) {
  GOOGLE_CHECK_NE(&from, this);
  acl_.MergeFrom(from.acl_);
}

void AccessControlList::CopyFrom(const AccessControlList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccessControlList::IsInitialized() const {

  for (int i = 0; i < acl_size(); i++) {
    if (!this->acl(i).IsInitialized()) return false;
  }
  return true;
}

void AccessControlList::Swap(AccessControlList* other) {
  if (other != this) {
    acl_.Swap(&other->acl_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AccessControlList::GetTypeName() const {
  return "mapr.fs.AccessControlList";
}


// ===================================================================

#ifndef _MSC_VER
const int Key::kKeyFieldNumber;
#endif  // !_MSC_VER

Key::Key()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Key::InitAsDefaultInstance() {
}

Key::Key(const Key& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Key::SharedCtor() {
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Key::~Key() {
  SharedDtor();
}

void Key::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Key::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Key& Key::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_security_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_security_2eproto();
#endif
  return *default_instance_;
}

Key* Key::default_instance_ = NULL;

Key* Key::New() const {
  return new Key;
}

void Key::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Key::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Key::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->key(), output);
  }

}

int Key::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Key::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Key*>(&from));
}

void Key::MergeFrom(const Key& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
  }
}

void Key::CopyFrom(const Key& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Key::IsInitialized() const {

  return true;
}

void Key::Swap(Key* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Key::GetTypeName() const {
  return "mapr.fs.Key";
}


// ===================================================================

#ifndef _MSC_VER
const int Ticket::kUserCredsFieldNumber;
const int Ticket::kUserKeyFieldNumber;
const int Ticket::kExpiryTimeFieldNumber;
const int Ticket::kCreationTimeSecFieldNumber;
const int Ticket::kMaxRenewalDurationSecFieldNumber;
const int Ticket::kIsExternalFieldNumber;
#endif  // !_MSC_VER

Ticket::Ticket()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Ticket::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  usercreds_ = const_cast< ::mapr::fs::CredentialsMsg*>(
      ::mapr::fs::CredentialsMsg::internal_default_instance());
#else
  usercreds_ = const_cast< ::mapr::fs::CredentialsMsg*>(&::mapr::fs::CredentialsMsg::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  userkey_ = const_cast< ::mapr::fs::Key*>(
      ::mapr::fs::Key::internal_default_instance());
#else
  userkey_ = const_cast< ::mapr::fs::Key*>(&::mapr::fs::Key::default_instance());
#endif
}

Ticket::Ticket(const Ticket& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Ticket::SharedCtor() {
  _cached_size_ = 0;
  usercreds_ = NULL;
  userkey_ = NULL;
  expirytime_ = GOOGLE_ULONGLONG(0);
  creationtimesec_ = GOOGLE_ULONGLONG(0);
  maxrenewaldurationsec_ = GOOGLE_ULONGLONG(0);
  isexternal_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Ticket::~Ticket() {
  SharedDtor();
}

void Ticket::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete usercreds_;
    delete userkey_;
  }
}

void Ticket::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Ticket& Ticket::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_security_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_security_2eproto();
#endif
  return *default_instance_;
}

Ticket* Ticket::default_instance_ = NULL;

Ticket* Ticket::New() const {
  return new Ticket;
}

void Ticket::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_usercreds()) {
      if (usercreds_ != NULL) usercreds_->::mapr::fs::CredentialsMsg::Clear();
    }
    if (has_userkey()) {
      if (userkey_ != NULL) userkey_->::mapr::fs::Key::Clear();
    }
    expirytime_ = GOOGLE_ULONGLONG(0);
    creationtimesec_ = GOOGLE_ULONGLONG(0);
    maxrenewaldurationsec_ = GOOGLE_ULONGLONG(0);
    isexternal_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Ticket::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mapr.fs.CredentialsMsg userCreds = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_usercreds()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_userKey;
        break;
      }

      // optional .mapr.fs.Key userKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_userKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_userkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_expiryTime;
        break;
      }

      // optional uint64 expiryTime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_expiryTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &expirytime_)));
          set_has_expirytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_creationTimeSec;
        break;
      }

      // optional uint64 creationTimeSec = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_creationTimeSec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &creationtimesec_)));
          set_has_creationtimesec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_maxRenewalDurationSec;
        break;
      }

      // optional uint64 maxRenewalDurationSec = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_maxRenewalDurationSec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &maxrenewaldurationsec_)));
          set_has_maxrenewaldurationsec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_isExternal;
        break;
      }

      // optional bool isExternal = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isExternal:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isexternal_)));
          set_has_isexternal();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Ticket::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mapr.fs.CredentialsMsg userCreds = 1;
  if (has_usercreds()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->usercreds(), output);
  }

  // optional .mapr.fs.Key userKey = 2;
  if (has_userkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->userkey(), output);
  }

  // optional uint64 expiryTime = 3;
  if (has_expirytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->expirytime(), output);
  }

  // optional uint64 creationTimeSec = 4;
  if (has_creationtimesec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->creationtimesec(), output);
  }

  // optional uint64 maxRenewalDurationSec = 5;
  if (has_maxrenewaldurationsec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->maxrenewaldurationsec(), output);
  }

  // optional bool isExternal = 6;
  if (has_isexternal()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->isexternal(), output);
  }

}

int Ticket::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mapr.fs.CredentialsMsg userCreds = 1;
    if (has_usercreds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->usercreds());
    }

    // optional .mapr.fs.Key userKey = 2;
    if (has_userkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->userkey());
    }

    // optional uint64 expiryTime = 3;
    if (has_expirytime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->expirytime());
    }

    // optional uint64 creationTimeSec = 4;
    if (has_creationtimesec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->creationtimesec());
    }

    // optional uint64 maxRenewalDurationSec = 5;
    if (has_maxrenewaldurationsec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->maxrenewaldurationsec());
    }

    // optional bool isExternal = 6;
    if (has_isexternal()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Ticket::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Ticket*>(&from));
}

void Ticket::MergeFrom(const Ticket& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_usercreds()) {
      mutable_usercreds()->::mapr::fs::CredentialsMsg::MergeFrom(from.usercreds());
    }
    if (from.has_userkey()) {
      mutable_userkey()->::mapr::fs::Key::MergeFrom(from.userkey());
    }
    if (from.has_expirytime()) {
      set_expirytime(from.expirytime());
    }
    if (from.has_creationtimesec()) {
      set_creationtimesec(from.creationtimesec());
    }
    if (from.has_maxrenewaldurationsec()) {
      set_maxrenewaldurationsec(from.maxrenewaldurationsec());
    }
    if (from.has_isexternal()) {
      set_isexternal(from.isexternal());
    }
  }
}

void Ticket::CopyFrom(const Ticket& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ticket::IsInitialized() const {

  return true;
}

void Ticket::Swap(Ticket* other) {
  if (other != this) {
    std::swap(usercreds_, other->usercreds_);
    std::swap(userkey_, other->userkey_);
    std::swap(expirytime_, other->expirytime_);
    std::swap(creationtimesec_, other->creationtimesec_);
    std::swap(maxrenewaldurationsec_, other->maxrenewaldurationsec_);
    std::swap(isexternal_, other->isexternal_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Ticket::GetTypeName() const {
  return "mapr.fs.Ticket";
}


// ===================================================================

#ifndef _MSC_VER
const int TicketAndKey::kEncryptedTicketFieldNumber;
const int TicketAndKey::kUserKeyFieldNumber;
const int TicketAndKey::kUserCredsFieldNumber;
const int TicketAndKey::kExpiryTimeFieldNumber;
const int TicketAndKey::kCreationTimeSecFieldNumber;
const int TicketAndKey::kMaxRenewalDurationSecFieldNumber;
#endif  // !_MSC_VER

TicketAndKey::TicketAndKey()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TicketAndKey::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  userkey_ = const_cast< ::mapr::fs::Key*>(
      ::mapr::fs::Key::internal_default_instance());
#else
  userkey_ = const_cast< ::mapr::fs::Key*>(&::mapr::fs::Key::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  usercreds_ = const_cast< ::mapr::fs::CredentialsMsg*>(
      ::mapr::fs::CredentialsMsg::internal_default_instance());
#else
  usercreds_ = const_cast< ::mapr::fs::CredentialsMsg*>(&::mapr::fs::CredentialsMsg::default_instance());
#endif
}

TicketAndKey::TicketAndKey(const TicketAndKey& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TicketAndKey::SharedCtor() {
  _cached_size_ = 0;
  encryptedticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  userkey_ = NULL;
  usercreds_ = NULL;
  expirytime_ = GOOGLE_ULONGLONG(0);
  creationtimesec_ = GOOGLE_ULONGLONG(0);
  maxrenewaldurationsec_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TicketAndKey::~TicketAndKey() {
  SharedDtor();
}

void TicketAndKey::SharedDtor() {
  if (encryptedticket_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedticket_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete userkey_;
    delete usercreds_;
  }
}

void TicketAndKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TicketAndKey& TicketAndKey::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_security_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_security_2eproto();
#endif
  return *default_instance_;
}

TicketAndKey* TicketAndKey::default_instance_ = NULL;

TicketAndKey* TicketAndKey::New() const {
  return new TicketAndKey;
}

void TicketAndKey::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_encryptedticket()) {
      if (encryptedticket_ != &::google::protobuf::internal::kEmptyString) {
        encryptedticket_->clear();
      }
    }
    if (has_userkey()) {
      if (userkey_ != NULL) userkey_->::mapr::fs::Key::Clear();
    }
    if (has_usercreds()) {
      if (usercreds_ != NULL) usercreds_->::mapr::fs::CredentialsMsg::Clear();
    }
    expirytime_ = GOOGLE_ULONGLONG(0);
    creationtimesec_ = GOOGLE_ULONGLONG(0);
    maxrenewaldurationsec_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TicketAndKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes encryptedTicket = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encryptedticket()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_userKey;
        break;
      }

      // optional .mapr.fs.Key userKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_userKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_userkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_userCreds;
        break;
      }

      // optional .mapr.fs.CredentialsMsg userCreds = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_userCreds:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_usercreds()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_expiryTime;
        break;
      }

      // optional uint64 expiryTime = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_expiryTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &expirytime_)));
          set_has_expirytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_creationTimeSec;
        break;
      }

      // optional uint64 creationTimeSec = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_creationTimeSec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &creationtimesec_)));
          set_has_creationtimesec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_maxRenewalDurationSec;
        break;
      }

      // optional uint64 maxRenewalDurationSec = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_maxRenewalDurationSec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &maxrenewaldurationsec_)));
          set_has_maxrenewaldurationsec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TicketAndKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes encryptedTicket = 1;
  if (has_encryptedticket()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->encryptedticket(), output);
  }

  // optional .mapr.fs.Key userKey = 2;
  if (has_userkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->userkey(), output);
  }

  // optional .mapr.fs.CredentialsMsg userCreds = 3;
  if (has_usercreds()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->usercreds(), output);
  }

  // optional uint64 expiryTime = 4;
  if (has_expirytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->expirytime(), output);
  }

  // optional uint64 creationTimeSec = 5;
  if (has_creationtimesec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->creationtimesec(), output);
  }

  // optional uint64 maxRenewalDurationSec = 6;
  if (has_maxrenewaldurationsec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->maxrenewaldurationsec(), output);
  }

}

int TicketAndKey::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes encryptedTicket = 1;
    if (has_encryptedticket()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encryptedticket());
    }

    // optional .mapr.fs.Key userKey = 2;
    if (has_userkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->userkey());
    }

    // optional .mapr.fs.CredentialsMsg userCreds = 3;
    if (has_usercreds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->usercreds());
    }

    // optional uint64 expiryTime = 4;
    if (has_expirytime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->expirytime());
    }

    // optional uint64 creationTimeSec = 5;
    if (has_creationtimesec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->creationtimesec());
    }

    // optional uint64 maxRenewalDurationSec = 6;
    if (has_maxrenewaldurationsec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->maxrenewaldurationsec());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TicketAndKey::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TicketAndKey*>(&from));
}

void TicketAndKey::MergeFrom(const TicketAndKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_encryptedticket()) {
      set_encryptedticket(from.encryptedticket());
    }
    if (from.has_userkey()) {
      mutable_userkey()->::mapr::fs::Key::MergeFrom(from.userkey());
    }
    if (from.has_usercreds()) {
      mutable_usercreds()->::mapr::fs::CredentialsMsg::MergeFrom(from.usercreds());
    }
    if (from.has_expirytime()) {
      set_expirytime(from.expirytime());
    }
    if (from.has_creationtimesec()) {
      set_creationtimesec(from.creationtimesec());
    }
    if (from.has_maxrenewaldurationsec()) {
      set_maxrenewaldurationsec(from.maxrenewaldurationsec());
    }
  }
}

void TicketAndKey::CopyFrom(const TicketAndKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TicketAndKey::IsInitialized() const {

  return true;
}

void TicketAndKey::Swap(TicketAndKey* other) {
  if (other != this) {
    std::swap(encryptedticket_, other->encryptedticket_);
    std::swap(userkey_, other->userkey_);
    std::swap(usercreds_, other->usercreds_);
    std::swap(expirytime_, other->expirytime_);
    std::swap(creationtimesec_, other->creationtimesec_);
    std::swap(maxrenewaldurationsec_, other->maxrenewaldurationsec_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TicketAndKey::GetTypeName() const {
  return "mapr.fs.TicketAndKey";
}


// ===================================================================

#ifndef _MSC_VER
const int AuthenticationReq::kChallengeFieldNumber;
#endif  // !_MSC_VER

AuthenticationReq::AuthenticationReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AuthenticationReq::InitAsDefaultInstance() {
}

AuthenticationReq::AuthenticationReq(const AuthenticationReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AuthenticationReq::SharedCtor() {
  _cached_size_ = 0;
  challenge_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AuthenticationReq::~AuthenticationReq() {
  SharedDtor();
}

void AuthenticationReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AuthenticationReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AuthenticationReq& AuthenticationReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_security_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_security_2eproto();
#endif
  return *default_instance_;
}

AuthenticationReq* AuthenticationReq::default_instance_ = NULL;

AuthenticationReq* AuthenticationReq::New() const {
  return new AuthenticationReq;
}

void AuthenticationReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    challenge_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AuthenticationReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 challenge = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &challenge_)));
          set_has_challenge();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AuthenticationReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 challenge = 1;
  if (has_challenge()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->challenge(), output);
  }

}

int AuthenticationReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 challenge = 1;
    if (has_challenge()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->challenge());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AuthenticationReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AuthenticationReq*>(&from));
}

void AuthenticationReq::MergeFrom(const AuthenticationReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_challenge()) {
      set_challenge(from.challenge());
    }
  }
}

void AuthenticationReq::CopyFrom(const AuthenticationReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthenticationReq::IsInitialized() const {

  return true;
}

void AuthenticationReq::Swap(AuthenticationReq* other) {
  if (other != this) {
    std::swap(challenge_, other->challenge_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AuthenticationReq::GetTypeName() const {
  return "mapr.fs.AuthenticationReq";
}


// ===================================================================

#ifndef _MSC_VER
const int AuthenticationReqFull::kEncryptedRandomSecretFieldNumber;
const int AuthenticationReqFull::kEncryptedTicketFieldNumber;
#endif  // !_MSC_VER

AuthenticationReqFull::AuthenticationReqFull()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AuthenticationReqFull::InitAsDefaultInstance() {
}

AuthenticationReqFull::AuthenticationReqFull(const AuthenticationReqFull& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AuthenticationReqFull::SharedCtor() {
  _cached_size_ = 0;
  encryptedrandomsecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  encryptedticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AuthenticationReqFull::~AuthenticationReqFull() {
  SharedDtor();
}

void AuthenticationReqFull::SharedDtor() {
  if (encryptedrandomsecret_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedrandomsecret_;
  }
  if (encryptedticket_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedticket_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AuthenticationReqFull::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AuthenticationReqFull& AuthenticationReqFull::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_security_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_security_2eproto();
#endif
  return *default_instance_;
}

AuthenticationReqFull* AuthenticationReqFull::default_instance_ = NULL;

AuthenticationReqFull* AuthenticationReqFull::New() const {
  return new AuthenticationReqFull;
}

void AuthenticationReqFull::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_encryptedrandomsecret()) {
      if (encryptedrandomsecret_ != &::google::protobuf::internal::kEmptyString) {
        encryptedrandomsecret_->clear();
      }
    }
    if (has_encryptedticket()) {
      if (encryptedticket_ != &::google::protobuf::internal::kEmptyString) {
        encryptedticket_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AuthenticationReqFull::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes encryptedRandomSecret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encryptedrandomsecret()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_encryptedTicket;
        break;
      }

      // optional bytes encryptedTicket = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encryptedTicket:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encryptedticket()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AuthenticationReqFull::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes encryptedRandomSecret = 1;
  if (has_encryptedrandomsecret()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->encryptedrandomsecret(), output);
  }

  // optional bytes encryptedTicket = 2;
  if (has_encryptedticket()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->encryptedticket(), output);
  }

}

int AuthenticationReqFull::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes encryptedRandomSecret = 1;
    if (has_encryptedrandomsecret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encryptedrandomsecret());
    }

    // optional bytes encryptedTicket = 2;
    if (has_encryptedticket()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encryptedticket());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AuthenticationReqFull::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AuthenticationReqFull*>(&from));
}

void AuthenticationReqFull::MergeFrom(const AuthenticationReqFull& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_encryptedrandomsecret()) {
      set_encryptedrandomsecret(from.encryptedrandomsecret());
    }
    if (from.has_encryptedticket()) {
      set_encryptedticket(from.encryptedticket());
    }
  }
}

void AuthenticationReqFull::CopyFrom(const AuthenticationReqFull& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthenticationReqFull::IsInitialized() const {

  return true;
}

void AuthenticationReqFull::Swap(AuthenticationReqFull* other) {
  if (other != this) {
    std::swap(encryptedrandomsecret_, other->encryptedrandomsecret_);
    std::swap(encryptedticket_, other->encryptedticket_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AuthenticationReqFull::GetTypeName() const {
  return "mapr.fs.AuthenticationReqFull";
}


// ===================================================================

#ifndef _MSC_VER
const int AuthenticationResp::kStatusFieldNumber;
const int AuthenticationResp::kChallengeResponseFieldNumber;
const int AuthenticationResp::kSessionKeyFieldNumber;
const int AuthenticationResp::kEncodingTypeFieldNumber;
#endif  // !_MSC_VER

AuthenticationResp::AuthenticationResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AuthenticationResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sessionkey_ = const_cast< ::mapr::fs::Key*>(
      ::mapr::fs::Key::internal_default_instance());
#else
  sessionkey_ = const_cast< ::mapr::fs::Key*>(&::mapr::fs::Key::default_instance());
#endif
}

AuthenticationResp::AuthenticationResp(const AuthenticationResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AuthenticationResp::SharedCtor() {
  _cached_size_ = 0;
  status_ = 0;
  challengeresponse_ = GOOGLE_ULONGLONG(0);
  sessionkey_ = NULL;
  encodingtype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AuthenticationResp::~AuthenticationResp() {
  SharedDtor();
}

void AuthenticationResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete sessionkey_;
  }
}

void AuthenticationResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AuthenticationResp& AuthenticationResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_security_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_security_2eproto();
#endif
  return *default_instance_;
}

AuthenticationResp* AuthenticationResp::default_instance_ = NULL;

AuthenticationResp* AuthenticationResp::New() const {
  return new AuthenticationResp;
}

void AuthenticationResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 0;
    challengeresponse_ = GOOGLE_ULONGLONG(0);
    if (has_sessionkey()) {
      if (sessionkey_ != NULL) sessionkey_->::mapr::fs::Key::Clear();
    }
    encodingtype_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AuthenticationResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_challengeResponse;
        break;
      }

      // optional uint64 challengeResponse = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_challengeResponse:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &challengeresponse_)));
          set_has_challengeresponse();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_sessionKey;
        break;
      }

      // optional .mapr.fs.Key sessionKey = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sessionKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sessionkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_encodingType;
        break;
      }

      // optional int32 encodingType = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_encodingType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &encodingtype_)));
          set_has_encodingtype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AuthenticationResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->status(), output);
  }

  // optional uint64 challengeResponse = 2;
  if (has_challengeresponse()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->challengeresponse(), output);
  }

  // optional .mapr.fs.Key sessionKey = 3;
  if (has_sessionkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->sessionkey(), output);
  }

  // optional int32 encodingType = 4;
  if (has_encodingtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->encodingtype(), output);
  }

}

int AuthenticationResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

    // optional uint64 challengeResponse = 2;
    if (has_challengeresponse()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->challengeresponse());
    }

    // optional .mapr.fs.Key sessionKey = 3;
    if (has_sessionkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sessionkey());
    }

    // optional int32 encodingType = 4;
    if (has_encodingtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->encodingtype());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AuthenticationResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AuthenticationResp*>(&from));
}

void AuthenticationResp::MergeFrom(const AuthenticationResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_challengeresponse()) {
      set_challengeresponse(from.challengeresponse());
    }
    if (from.has_sessionkey()) {
      mutable_sessionkey()->::mapr::fs::Key::MergeFrom(from.sessionkey());
    }
    if (from.has_encodingtype()) {
      set_encodingtype(from.encodingtype());
    }
  }
}

void AuthenticationResp::CopyFrom(const AuthenticationResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthenticationResp::IsInitialized() const {

  return true;
}

void AuthenticationResp::Swap(AuthenticationResp* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(challengeresponse_, other->challengeresponse_);
    std::swap(sessionkey_, other->sessionkey_);
    std::swap(encodingtype_, other->encodingtype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AuthenticationResp::GetTypeName() const {
  return "mapr.fs.AuthenticationResp";
}


// ===================================================================

#ifndef _MSC_VER
const int TicketDescriptor::kKeyTypeFieldNumber;
#endif  // !_MSC_VER

TicketDescriptor::TicketDescriptor()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TicketDescriptor::InitAsDefaultInstance() {
}

TicketDescriptor::TicketDescriptor(const TicketDescriptor& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TicketDescriptor::SharedCtor() {
  _cached_size_ = 0;
  keytype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TicketDescriptor::~TicketDescriptor() {
  SharedDtor();
}

void TicketDescriptor::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TicketDescriptor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TicketDescriptor& TicketDescriptor::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_security_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_security_2eproto();
#endif
  return *default_instance_;
}

TicketDescriptor* TicketDescriptor::default_instance_ = NULL;

TicketDescriptor* TicketDescriptor::New() const {
  return new TicketDescriptor;
}

void TicketDescriptor::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    keytype_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TicketDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mapr.fs.ServerKeyType keyType = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mapr::fs::ServerKeyType_IsValid(value)) {
            set_keytype(static_cast< ::mapr::fs::ServerKeyType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TicketDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mapr.fs.ServerKeyType keyType = 1;
  if (has_keytype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->keytype(), output);
  }

}

int TicketDescriptor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mapr.fs.ServerKeyType keyType = 1;
    if (has_keytype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->keytype());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TicketDescriptor::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TicketDescriptor*>(&from));
}

void TicketDescriptor::MergeFrom(const TicketDescriptor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_keytype()) {
      set_keytype(from.keytype());
    }
  }
}

void TicketDescriptor::CopyFrom(const TicketDescriptor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TicketDescriptor::IsInitialized() const {

  return true;
}

void TicketDescriptor::Swap(TicketDescriptor* other) {
  if (other != this) {
    std::swap(keytype_, other->keytype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TicketDescriptor::GetTypeName() const {
  return "mapr.fs.TicketDescriptor";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fs
}  // namespace mapr

// @@protoc_insertion_point(global_scope)
